<!DOCTYPE html>

<html>
<head>
    <meta charset="utf-8">
    <title>EMG mouse tool</title>
</head>
<body>
<div id="app" style="position: absolute; right: 0; width: 130px">
<input type="checkbox" id="enabled_checkbox" style="display: block; width: 3em; height: 3em" />
    <div id="followers"></div>
<canvas id="canvas" width="130" height="500" />
</div>
<script>


const canvas = document.getElementById ("canvas");
const followers_element = document.getElementById ("followers");
const context = canvas.getContext ("2d");
const enabled_checkbox = document.getElementById ("enabled_checkbox");

let previous_data = null;

enabled_checkbox.addEventListener("click", e => {
  fetch ("/input", {
    method: "POST",
    body: JSON.stringify ({SetEnabled: enabled_checkbox.checked}),
  });
});

      function update_canvas(data) {
        context.clearRect (0, 0, canvas.width, canvas.height);
        function print_line (history, key) {
            const last = history[history.length - 1];
            context.beginPath();
            history.forEach((frame, index) => {
              const x = canvas.width * (1.0 - (last.time - frame.time) / 0.8);
              const y = (-Math.log(frame [key] * 0.999 + 0.001) / Math.log(0.001) + 1) * canvas.height / 2;
              if (index == 0) {
                context.moveTo(x,y)
                 } else {
                  context.lineTo(x,y);
                  }
            });
            context.stroke();
        }
        colors = ["#ffbb00", "#ff88ff", "#000000", "#55ffff"];
        data.histories.forEach((history, index) => {
            context.strokeStyle = colors[index];
            print_line (history, "value");
        });
        context.strokeStyle = "#88ff88";
        data.histories.forEach((history, index) => {
            if (index == 2) {
                print_line (history, "click_threshold");
            }
        });
        context.strokeStyle = "#ff8888";
        data.histories.forEach((history, index) => {
            if (index == 2) {
                print_line (history, "too_much_threshold");
            }
        });

            data.frequencies_history.forEach((frequencies, time_index) => {
            const box_width = canvas.width / data.frequencies_history.length;
            const box_height = canvas.height / data.frequencies_history [0].length / 2;
            frequencies.forEach((intensity, frequency_index) => {
    context.fillStyle = `rgb(
        ${Math.floor(255 * intensity)},
        ${Math.floor(255 * intensity)},
        0)`;
    context.fillRect(time_index * box_width, frequency_index * box_height+ canvas.height / 2, box_width, box_height);
  })
})
      }
      function update_followers(data) {
        const ids = {};
        for (const [name,duration] of data.followers) {
          const id = "follower_" + name;
          ids[id] = true;
          let element =document.getElementById (id);
          if (!element) {
            element = document.createElement("div");
            element.id = id;
            followers_element.appendChild(element);
          }
          const text = name+": "+duration;
          if (element.innerText != text) {
            element.innerText = text;
          }
        }

        for (const child of followers_element.children) {
          if (!ids[child.id]) {
            child.remove();
          }
        }
      }

      async function frame() {
          try {
            const response = await fetch ("/state_update", {
              method: "POST",
            });
            if (response.ok) {
              const data = await response.json();
              if (data !== null) {
                update_canvas(data);
                update_followers(data);
                enabled_checkbox.checked = data.enabled;
              }
            }
          }
          finally {
            requestAnimationFrame (frame);
          }
      }

      frame();



    </script>
</body>
</html>